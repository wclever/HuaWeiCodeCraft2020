热身赛146 0.96    西北赛区：初赛 40 0.4798   复活赛区：复赛a榜26 / b榜4

热身赛：机器学习，训练算法提升时间和准确度，根据时间和准确度综合判分

初赛：循环转账，寻找全部循环路径在[3,7]之间

复赛a榜：在初赛要求基础上使得前后转账金额在一定范围内

复赛b榜：转账金额整数变为浮点数，环数改为[3,8]之间

trick:(时间根据1963w结果计算)

读入数据100ms

* 使用mmap方式读入最快，200w条读入存储小于
* `,`方式分割数据，`\n`划分转账金额
* 换行通配符（很多大佬复赛b榜滑铁卢）由于window下的换行是`\r\n`CRLF，Linux下是`\n`LF，所以每次判读前先判断`\r`后判断`\n`
* 数据使用数组存储，边的顶点存在一起，金额另外数组存储

预处理，建图1.6s偏慢

* 拷贝一份输入数组排序去重统计顶点数量
* 使用unordered_map映射成连续的顶点ID
* 使用vector存储顶点转换的结果字符串`"123,"`,`"123\n"`
* 初赛数据小使用二维数组建图，复赛使用vector\<vector\<Pair>>方式存图（比自己定义的结构体快），使用sort对每个点的邻接边排序
* 统计出入度
* 拓扑排序（去掉不成环的点）实际作用不大，后期去掉了

找环

* 使用4+3双向搜索的方式（可以根据出入度对比分别使用4+3和3+4得到3.5+3.5）
* 使用unordered_map<uint32_t, vector\<Index>>存储反向搜索得到的反向边并且需要排序后再找环
* 采用抢占负载均衡多线程找环，atomic_flag，四个线程搜索未置位的点找环
* dfs方式使用for循环展开成反3+正4
* 减少使用if continue的操作，使得程序强行跳转

写入文件

* 使用new数组存储结果数据，重新连接负载均衡找环的结果
* 使用mmap写文件，将结果字符串拼接，使用strcpy传入内存
* ftruncate重新划定文件大小

###上分经历

**1.初始版本**

> 实现初赛终版6+1四线程，并全部改回使用STL的方式
>
> 线上分数：178.6

**2.改成4+3**

> 使用vector<vector\<Index>>方式存储反向边
>
> 线上分数：27.1

**3.使用抢占式调度**

> atomic_flag方式抢占调度
>
> 没有测试线上效果

**复赛b榜**

> 4+3方式直接改为4+4方式，抢占式调度版本，转账金额使用double存储，结果错误
>
> 非抢占调度版本，转账金额使用double存储，结果错误
>
> 抢占式版本，转账金额使用long long存储，结果通过，时间10.4s
>
> 然后就没时间改了。。。